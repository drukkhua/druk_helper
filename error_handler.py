"""
–°–∏—Å—Ç–µ–º–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –¥–ª—è –±–æ—Ç–∞
"""

import traceback
from functools import wraps

import json
from aiogram import types
from aiogram.exceptions import TelegramAPIError as AiogramTelegramAPIError
from aiogram.types import CallbackQuery, Message
from datetime import datetime
from typing import Any, Callable, Dict, Optional

from config import ADMIN_USER_IDS, logger
from exceptions import *


class ErrorHandler:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫ –±–æ—Ç–∞"""

    def __init__(self) -> None:
        self.error_stats = {}
        self.error_log_file = "error_log.json"

    def log_error(self, error: Exception, context: Optional[Dict[str, Any]] = None) -> None:
        """
        –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–∫–∏

        Args:
            error: –ò—Å–∫–ª—é—á–µ–Ω–∏–µ
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç –æ—à–∏–±–∫–∏
        """
        error_data = {
            "timestamp": datetime.now().isoformat(),
            "error_type": type(error).__name__,
            "message": str(error),
            "traceback": traceback.format_exc(),
            "context": context or {},
        }

        # –õ–æ–≥–∏—Ä—É–µ–º –≤ —Ñ–∞–π–ª
        try:
            with open(self.error_log_file, "a", encoding="utf-8") as f:
                f.write(json.dumps(error_data, ensure_ascii=False) + "\n")
        except Exception as e:
            logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø–∏—Å–∞—Ç—å –≤ –ª–æ–≥ –æ—à–∏–±–æ–∫: {e}")

        # –õ–æ–≥–∏—Ä—É–µ–º –≤ –∫–æ–Ω—Å–æ–ª—å
        logger.error(f"Error: {error_data}")

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        error_type = type(error).__name__
        if error_type not in self.error_stats:
            self.error_stats[error_type] = 0
        self.error_stats[error_type] += 1

    async def handle_error(self, error: Exception, update: Optional[types.Update] = None) -> None:
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏ —Å –æ—Ç–ø—Ä–∞–≤–∫–æ–π —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é

        Args:
            error: –ò—Å–∫–ª—é—á–µ–Ω–∏–µ
            update: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ Telegram
        """
        context = {}
        user_id = None

        # –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏–∑ update
        if update:
            if update.message:
                user_id = update.message.from_user.id
                context["message_text"] = update.message.text
                context["chat_id"] = update.message.chat.id
            elif update.callback_query:
                user_id = update.callback_query.from_user.id
                context["callback_data"] = update.callback_query.data
                context["chat_id"] = update.callback_query.message.chat.id

        context["user_id"] = user_id

        # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
        self.log_error(error, context)

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        await self._send_user_notification(error, update, user_id)

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∞–º –æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–∫–∞—Ö
        if isinstance(error, (DatabaseError, ConfigurationError, ExternalAPIError)):
            await self._send_admin_notification(error, context)

    async def _send_user_notification(
        self, error: Exception, update: Optional[types.Update], user_id: Optional[int]
    ) -> None:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
        if not update:
            return

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –æ—à–∏–±–∫–∏ –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ
        if isinstance(error, ValidationError):
            message = "‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
        elif isinstance(error, TemplateNotFoundError):
            message = "‚ùå –®–∞–±–ª–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
        elif isinstance(error, RateLimitExceededError):
            message = "‚è∞ –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ."
        elif isinstance(error, AdminOnlyError):
            message = "üîí –î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤."
        elif isinstance(error, SecurityError):
            message = "üõ°Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å."
        elif isinstance(error, (DatabaseError, FileNotFoundError)):
            message = "üìÇ –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–∞–Ω–Ω—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        elif isinstance(error, ExternalAPIError):
            message = "üåê –ü—Ä–æ–±–ª–µ–º–∞ —Å –≤–Ω–µ—à–Ω–∏–º —Å–µ—Ä–≤–∏—Å–æ–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        elif isinstance(error, TelegramAPIError):
            message = "üì± –û—à–∏–±–∫–∞ Telegram API. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        else:
            message = "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."

        try:
            if update.message:
                await update.message.answer(message)
            elif update.callback_query:
                await update.callback_query.answer(message)
        except Exception as e:
            logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é: {e}")

    async def _send_admin_notification(self, error: Exception, context: Dict[str, Any]) -> None:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞–º –æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–∫–∞—Ö"""
        if not ADMIN_USER_IDS:
            return

        error_message = (
            f"üö® –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –±–æ—Ç–∞:\n\n"
            f"**–¢–∏–ø:** {type(error).__name__}\n"
            f"**–°–æ–æ–±—â–µ–Ω–∏–µ:** {str(error)}\n"
            f"**–í—Ä–µ–º—è:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            f"**–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:** {context.get('user_id', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}\n"
            f"**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** {json.dumps(context, ensure_ascii=False, indent=2)}"
        )

        # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞–º
        # –ù–∞–ø—Ä–∏–º–µ—Ä, —á–µ—Ä–µ–∑ –æ—Ç–¥–µ–ª—å–Ω—ã–π –±–æ—Ç –∏–ª–∏ webhook
        logger.critical(f"Admin notification: {error_message}")

    def get_error_stats(self) -> Dict[str, int]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –æ—à–∏–±–æ–∫"""
        return self.error_stats.copy()

    def clear_error_stats(self) -> None:
        """–û—á–∏—Å—Ç–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –æ—à–∏–±–æ–∫"""
        self.error_stats.clear()


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
error_handler = ErrorHandler()


def handle_exceptions(func: Callable) -> Callable:
    """
    –î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–∫–ª—é—á–µ–Ω–∏–π
    """

    @wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except BotException as e:
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –Ω–∞—à–∏ –∫–∞—Å—Ç–æ–º–Ω—ã–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è
            update = None
            for arg in args:
                if isinstance(arg, (Message, CallbackQuery)):
                    update = (
                        types.Update(message=arg)
                        if isinstance(arg, Message)
                        else types.Update(callback_query=arg)
                    )
                    break

            await error_handler.handle_error(e, update)

        except AiogramTelegramAPIError as e:
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—à–∏–±–∫–∏ Telegram API
            telegram_error = TelegramAPIError(
                f"Telegram API Error: {str(e)}", details={"original_error": str(e)}
            )

            update = None
            for arg in args:
                if isinstance(arg, (Message, CallbackQuery)):
                    update = (
                        types.Update(message=arg)
                        if isinstance(arg, Message)
                        else types.Update(callback_query=arg)
                    )
                    break

            await error_handler.handle_error(telegram_error, update)

        except Exception as e:
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è
            generic_error = BotException(
                f"Unexpected error: {str(e)}",
                details={"original_error": str(e), "traceback": traceback.format_exc()},
            )

            update = None
            for arg in args:
                if isinstance(arg, (Message, CallbackQuery)):
                    update = (
                        types.Update(message=arg)
                        if isinstance(arg, Message)
                        else types.Update(callback_query=arg)
                    )
                    break

            await error_handler.handle_error(generic_error, update)

    return wrapper


def safe_execute(func: Callable, *args, **kwargs) -> Any:
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –æ—à–∏–±–æ–∫
    """
    try:
        return func(*args, **kwargs)
    except Exception as e:
        error_handler.log_error(
            e, {"function": func.__name__, "args": str(args), "kwargs": str(kwargs)}
        )
        return None


class CircuitBreaker:
    """
    –ü–∞—Ç—Ç–µ—Ä–Ω Circuit Breaker –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –∫–∞—Å–∫–∞–¥–Ω—ã—Ö –æ—à–∏–±–æ–∫
    """

    def __init__(self, failure_threshold: int = 5, recovery_timeout: int = 60) -> None:
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN

    def call(self, func: Callable, *args, **kwargs):
        """–í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ —á–µ—Ä–µ–∑ Circuit Breaker"""
        if self.state == "OPEN":
            if self._should_attempt_reset():
                self.state = "HALF_OPEN"
            else:
                raise ExternalAPIError("Circuit breaker is OPEN")

        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e

    def _should_attempt_reset(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞, —Å—Ç–æ–∏—Ç –ª–∏ –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è —Å–±—Ä–æ—Å–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ"""
        if self.last_failure_time is None:
            return True

        return (datetime.now() - self.last_failure_time).seconds >= self.recovery_timeout

    def _on_success(self) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —É—Å–ø–µ—à–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞"""
        self.failure_count = 0
        self.state = "CLOSED"

    def _on_failure(self) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ—É–¥–∞—á–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞"""
        self.failure_count += 1
        self.last_failure_time = datetime.now()

        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π Circuit Breaker –¥–ª—è –≤–Ω–µ—à–Ω–∏—Ö API
external_api_circuit_breaker = CircuitBreaker()


def with_circuit_breaker(circuit_breaker: CircuitBreaker):
    """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è Circuit Breaker"""

    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            return circuit_breaker.call(func, *args, **kwargs)

        return wrapper

    return decorator
