"""
–°–∏—Å—Ç–µ–º–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤
–ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∞ —Å –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω–æ–π SQLite –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
"""

from aiogram import Bot, types
from aiogram.exceptions import TelegramBadRequest, TelegramForbiddenError
from typing import List, Dict, Optional
import logging
import json
from datetime import datetime

from src.managers.models import unified_db, Manager, ManagerStatus, ConversationMessage, MessageType
from config import Config

logger = logging.getLogger(__name__)


class ManagerNotificationSystem:
    """–°–∏—Å—Ç–µ–º–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤"""

    def __init__(self, bot: Bot):
        self.bot = bot
        self.db = unified_db

    async def notify_new_client(
        self, client_message: types.Message, urgency: str = "normal"
    ) -> List[int]:
        """–£–≤–µ–¥–æ–º–ª—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –æ –Ω–æ–≤–æ–º –∫–ª–∏–µ–Ω—Ç–µ"""

        # –ü–æ–ª—É—á–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤
        available_managers = self.db.get_available_managers_now()

        if not available_managers:
            # –ù–∏–∫–æ–≥–æ –Ω–µ—Ç –≤ —Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è - —É–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö
            available_managers = self.db.get_active_managers()
            urgency = "after_hours"  # –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –≤–Ω–µ—Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è

        if not available_managers:
            logger.warning("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è")
            return []

        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–ª–∏–µ–Ω—Ç–µ
        client_info = self._extract_client_info(client_message)

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é
        await self._save_client_message(client_info, client_message)

        # –§–æ—Ä–º–∏—Ä—É–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        notification = self._create_notification_message(client_info, urgency)
        keyboard = self._create_manager_keyboard(client_info["telegram_id"])

        notified_managers = []

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        for manager in available_managers:
            try:
                await self.bot.send_message(
                    chat_id=manager.telegram_id,
                    text=notification,
                    reply_markup=keyboard,
                    parse_mode="Markdown",
                )
                notified_managers.append(manager.telegram_id)
                logger.info(f"–£–≤–µ–¥–æ–º–ª–µ–Ω –º–µ–Ω–µ–¥–∂–µ—Ä {manager.name} ({manager.telegram_id})")

            except (TelegramBadRequest, TelegramForbiddenError) as e:
                logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä—É {manager.telegram_id}: {e}")
                # –ú–µ–Ω–µ–¥–∂–µ—Ä –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞ - –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–≥–æ
                self.db.update_manager_status(manager.telegram_id, ManagerStatus.OFFLINE)

        return notified_managers

    async def notify_file_upload(
        self, client_message: types.Message, file_analysis: Dict
    ) -> List[int]:
        """–£–≤–µ–¥–æ–º–ª—è–µ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –æ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞"""

        available_managers = self.db.get_available_managers_now()
        client_info = self._extract_client_info(client_message)

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
        await self._save_file_message(client_info, client_message, file_analysis)

        # –°–ø–µ—Ü–∏–∞–ª—å–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è —Ñ–∞–π–ª–æ–≤
        notification = self._create_file_notification(client_info, file_analysis)
        keyboard = self._create_manager_keyboard(client_info["telegram_id"])

        notified_managers = []

        for manager in available_managers:
            try:
                await self.bot.send_message(
                    chat_id=manager.telegram_id,
                    text=notification,
                    reply_markup=keyboard,
                    parse_mode="Markdown",
                )
                notified_managers.append(manager.telegram_id)

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Ñ–∞–π–ª–µ: {e}")

        return notified_managers

    async def notify_high_priority(self, client_message: types.Message, reason: str) -> List[int]:
        """–£–≤–µ–¥–æ–º–ª—è–µ—Ç –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –æ –≤—ã—Å–æ–∫–æ–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ–º –∫–ª–∏–µ–Ω—Ç–µ"""

        all_active = self.db.get_active_managers()
        client_info = self._extract_client_info(client_message)

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        await self._save_priority_message(client_info, client_message, reason)

        notification = f"""üö® **–ü–†–ò–û–†–ò–¢–ï–¢–ù–´–ô –ö–õ–ò–ï–ù–¢**

{self._create_notification_message(client_info, "high")}

‚ö†Ô∏è **–ü—Ä–∏—á–∏–Ω–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞:** {reason}
"""

        keyboard = self._create_manager_keyboard(client_info["telegram_id"])

        notified_managers = []

        for manager in all_active:
            try:
                await self.bot.send_message(
                    chat_id=manager.telegram_id,
                    text=notification,
                    reply_markup=keyboard,
                    parse_mode="Markdown",
                )
                notified_managers.append(manager.telegram_id)

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")

        return notified_managers

    async def notify_client_taken(self, client_id: int, manager_name: str, manager_id: int):
        """–£–≤–µ–¥–æ–º–ª—è–µ—Ç –¥—Ä—É–≥–∏—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤, —á—Ç–æ –∫–ª–∏–µ–Ω—Ç –≤–∑—è—Ç –≤ —Ä–∞–±–æ—Ç—É"""

        active_managers = self.db.get_active_managers()

        for manager in active_managers:
            if manager.telegram_id == manager_id:
                continue  # –ù–µ —É–≤–µ–¥–æ–º–ª—è–µ–º —Å–∞–º–æ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞

            try:
                await self.bot.send_message(
                    manager.telegram_id,
                    f"‚ÑπÔ∏è **–ö–ª–∏–µ–Ω—Ç –≤–∑—è—Ç –≤ —Ä–∞–±–æ—Ç—É**\n\n"
                    f"üë§ –ö–ª–∏–µ–Ω—Ç ID: `{client_id}`\n"
                    f"üë®‚Äçüíº –ú–µ–Ω–µ–¥–∂–µ—Ä: {manager_name}\n"
                    f"üïê –í—Ä–µ–º—è: {datetime.now().strftime('%H:%M')}",
                    parse_mode="Markdown",
                )
            except Exception as e:
                logger.warning(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –º–∞—Å—Å–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
                # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –º–∞—Å—Å–æ–≤—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π, –Ω–æ –ª–æ–≥–∏—Ä—É–µ–º –∏—Ö

    def _extract_client_info(self, message: types.Message) -> Dict:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–ª–∏–µ–Ω—Ç–µ"""
        user = message.from_user

        return {
            "telegram_id": user.id,
            "name": user.full_name or "–ë–µ–∑ –∏–º–µ–Ω–∏",
            "username": f"@{user.username}" if user.username else "–ë–µ–∑ username",
            "query": message.text or message.caption or "[—Ñ–∞–π–ª/–º–µ–¥–∏–∞]",
            "message_time": message.date.strftime("%H:%M"),
            "message_date": message.date.strftime("%d.%m.%Y"),
            "language_code": user.language_code or "uk",
            "message_id": message.message_id,
        }

    async def _save_client_message(self, client_info: Dict, message: types.Message):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é"""
        try:
            conv_message = ConversationMessage(
                user_id=client_info["telegram_id"],
                message_type=MessageType.USER,
                content=client_info["query"],
                timestamp=message.date,
                category=self._detect_message_category(client_info["query"]),
                file_info=(
                    self._extract_file_info(message) if message.document or message.photo else None
                ),
            )

            self.db.save_message(conv_message)
            logger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {client_info['telegram_id']}")

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞: {e}")

    async def _save_file_message(
        self, client_info: Dict, message: types.Message, file_analysis: Dict
    ):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–º —Ñ–∞–π–ª–µ"""
        try:
            file_info = {
                "file_name": file_analysis.get("file_name", "unknown"),
                "file_size": file_analysis.get("file_size", 0),
                "file_extension": file_analysis.get("file_extension", ""),
                "file_type": file_analysis.get("file_type", "unknown"),
                "quality_assessment": file_analysis.get("quality_assessment", "unknown"),
                "suitable_for_print": file_analysis.get("suitable_for_print", False),
            }

            conv_message = ConversationMessage(
                user_id=client_info["telegram_id"],
                message_type=MessageType.USER,
                content=f"–ó–∞–≥—Ä—É–∂–µ–Ω —Ñ–∞–π–ª: {file_info['file_name']}",
                timestamp=message.date,
                category="—Ñ–∞–π–ª—ã",
                file_info=json.dumps(file_info, ensure_ascii=False),
            )

            self.db.save_message(conv_message)
            logger.info(
                f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ñ–∞–π–ª–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {client_info['telegram_id']}"
            )

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ñ–∞–π–ª–µ: {e}")

    async def _save_priority_message(self, client_info: Dict, message: types.Message, reason: str):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"""
        try:
            conv_message = ConversationMessage(
                user_id=client_info["telegram_id"],
                message_type=MessageType.USER,
                content=client_info["query"],
                timestamp=message.date,
                category="–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç",
                file_info=json.dumps({"priority_reason": reason}, ensure_ascii=False),
            )

            self.db.save_message(conv_message)

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")

    def _detect_message_category(self, message_text: str) -> Optional[str]:
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É"""
        if not message_text:
            return None

        text_lower = message_text.lower()

        # –ü—Ä–æ—Å—Ç–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏—è –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
        if any(word in text_lower for word in ["—Ü–µ–Ω–∞", "—Å—Ç–æ–∏–º–æ—Å—Ç—å", "—Å–∫–æ–ª—å–∫–æ —Å—Ç–æ–∏—Ç", "–ø—Ä–∞–π—Å"]):
            return "—Ü–µ–Ω—ã"
        elif any(word in text_lower for word in ["—Å—Ä–æ–∫", "–∫–æ–≥–¥–∞ –≥–æ—Ç–æ–≤–æ", "–±—ã—Å—Ç—Ä–æ", "—Å—Ä–æ—á–Ω–æ"]):
            return "—Å—Ä–æ–∫–∏"
        elif any(word in text_lower for word in ["–º–∞–∫–µ—Ç", "–¥–∏–∑–∞–π–Ω", "—Ñ–∞–π–ª"]):
            return "–º–∞–∫–µ—Ç—ã"
        elif any(word in text_lower for word in ["–º–∞—Ç–µ—Ä–∏–∞–ª", "–±—É–º–∞–≥–∞", "–∫–∞—á–µ—Å—Ç–≤–æ"]):
            return "–º–∞—Ç–µ—Ä–∏–∞–ª—ã"
        elif any(word in text_lower for word in ["–≤–∏–∑–∏—Ç–∫–∏", "–≤–∏–∑–∏—Ç–∫–∞"]):
            return "–≤–∏–∑–∏—Ç–∫–∏"
        elif any(word in text_lower for word in ["–ª–∏—Å—Ç–æ–≤–∫–∏", "–ª–∏—Å—Ç–æ–≤–∫–∞"]):
            return "–ª–∏—Å—Ç–æ–≤–∫–∏"
        elif any(word in text_lower for word in ["–Ω–∞–∫–ª–µ–π–∫–∏", "–Ω–∞–∫–ª–µ–π–∫–∞"]):
            return "–Ω–∞–∫–ª–µ–π–∫–∏"
        else:
            return "–æ–±—â–∏–µ"

    def _extract_file_info(self, message: types.Message) -> Optional[str]:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–∞—Ö –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        if message.document:
            return json.dumps(
                {
                    "type": "document",
                    "file_name": message.document.file_name,
                    "file_size": message.document.file_size,
                    "mime_type": message.document.mime_type,
                },
                ensure_ascii=False,
            )
        elif message.photo:
            photo = message.photo[-1]  # –ë–µ—Ä–µ–º —Å–∞–º–æ–µ –±–æ–ª—å—à–æ–µ —Ñ–æ—Ç–æ
            return json.dumps(
                {
                    "type": "photo",
                    "file_size": photo.file_size,
                    "width": photo.width,
                    "height": photo.height,
                },
                ensure_ascii=False,
            )

        return None

    def _create_notification_message(self, client_info: Dict, urgency: str = "normal") -> str:
        """–°–æ–∑–¥–∞–µ—Ç —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"""

        urgency_config = {
            "low": {"emoji": "üìù", "title": "–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"},
            "normal": {"emoji": "üìû", "title": "–ù–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç –∂–¥–µ—Ç –æ—Ç–≤–µ—Ç!"},
            "high": {"emoji": "üö®", "title": "–°–†–û–ß–ù–û! –ö–ª–∏–µ–Ω—Ç –∂–¥–µ—Ç –æ—Ç–≤–µ—Ç!"},
            "urgent": {"emoji": "üî•", "title": "–ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û!"},
            "after_hours": {"emoji": "üåô", "title": "–°–æ–æ–±—â–µ–Ω–∏–µ –≤–æ –≤–Ω–µ—Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è"},
        }

        config = urgency_config.get(urgency, urgency_config["normal"])
        emoji = config["emoji"]
        title = config["title"]

        # –û–±—Ä–µ–∑–∞–µ–º –¥–ª–∏–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å
        query = client_info["query"]
        if len(query) > 100:
            query = query[:97] + "..."

        # –ü–æ–ª—É—á–∞–µ–º –∫—Ä–∞—Ç–∫—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–ª–∏–µ–Ω—Ç–∞
        client_stats = self._get_client_brief_stats(client_info["telegram_id"])

        base_message = f"""{emoji} **{title}**

üë§ **–ö–ª–∏–µ–Ω—Ç:** {client_info['name']}
üì± **Username:** {client_info['username']}
üÜî **ID:** `{client_info['telegram_id']}`

üí¨ **–°–æ–æ–±—â–µ–Ω–∏–µ:**
_{query}_

üïê **–í—Ä–µ–º—è:** {client_info['message_time']}"""

        # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–ª–∏–µ–Ω—Ç–∞ –µ—Å–ª–∏ –µ—Å—Ç—å –∏—Å—Ç–æ—Ä–∏—è
        if client_stats["total_messages"] > 1:
            base_message += f"\n\nüìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞:**"
            base_message += f"\n‚Ä¢ –í—Å–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–π: {client_stats['total_messages']}"
            if client_stats["last_interaction"]:
                base_message += f"\n‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ: {client_stats['last_interaction']}"
            if client_stats["favorite_category"]:
                base_message += f"\n‚Ä¢ –ß–∞—â–µ —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç –æ: {client_stats['favorite_category']}"

        if urgency == "after_hours":
            base_message += f"\n\nüåô _–°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ –≤–æ –≤–Ω–µ—Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è_"

        base_message += f'\n\n‚ö° **–ù–∞–∂–º–∏—Ç–µ "–û—Ç–≤–µ—Ç–∏—Ç—å" –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –¥–∏–∞–ª–æ–≥—É**'

        return base_message

    def _get_client_brief_stats(self, client_id: int) -> Dict:
        """–ü–æ–ª—É—á–∞–µ—Ç –∫—Ä–∞—Ç–∫—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–ª–∏–µ–Ω—Ç–∞"""
        try:
            stats = self.db.get_user_stats_summary(client_id)

            last_interaction = None
            if stats.get("last_message"):
                last_dt = datetime.fromisoformat(stats["last_message"])
                # –ï—Å–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–µ
                if last_dt.date() != datetime.now().date():
                    last_interaction = last_dt.strftime("%d.%m")

            return {
                "total_messages": stats.get("total_messages", 0),
                "last_interaction": last_interaction,
                "favorite_category": stats.get("top_category", None),
            }
        except:
            return {"total_messages": 0, "last_interaction": None, "favorite_category": None}

    def _create_file_notification(self, client_info: Dict, file_analysis: Dict) -> str:
        """–°–æ–∑–¥–∞–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞"""

        quality_emoji = {"excellent": "üåü", "good": "‚úÖ", "medium": "‚ö†Ô∏è", "needs_check": "üîç"}

        quality = file_analysis.get("quality_assessment", "unknown")
        quality_icon = quality_emoji.get(quality, "‚ùì")

        return f"""üìÅ **–ö–ª–∏–µ–Ω—Ç –∑–∞–≥—Ä—É–∑–∏–ª –º–∞–∫–µ—Ç!**

üë§ **–ö–ª–∏–µ–Ω—Ç:** {client_info['name']}
üì± **Username:** {client_info['username']}
üÜî **ID:** `{client_info['telegram_id']}`

üìã **–ê–Ω–∞–ª–∏–∑ —Ñ–∞–π–ª–∞:**
‚Ä¢ **–ù–∞–∑–≤–∞–Ω–∏–µ:** {file_analysis.get('file_name', 'unknown')}
‚Ä¢ **–†–∞–∑–º–µ—Ä:** {file_analysis.get('file_size_mb', 0)} –ú–ë
‚Ä¢ **–§–æ—Ä–º–∞—Ç:** {file_analysis.get('file_extension', 'unknown')} ({file_analysis.get('file_type', 'unknown')})
‚Ä¢ **–ö–∞—á–µ—Å—Ç–≤–æ –¥–ª—è –ø–µ—á–∞—Ç–∏:** {quality_icon} {quality}
‚Ä¢ **–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –ø–æ–ª–∏–≥—Ä–∞—Ñ–∏–∏:** {'‚úÖ –î–∞' if file_analysis.get('suitable_for_print', False) else '‚ùå –ù–µ—Ç'}

üïê **–í—Ä–µ–º—è:** {client_info['message_time']}

‚úÖ **–ö–ª–∏–µ–Ω—Ç—É —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç –æ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ñ–∞–π–ª–∞**"""

    def _create_manager_keyboard(self, client_telegram_id: int) -> types.InlineKeyboardMarkup:
        """–°–æ–∑–¥–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞"""

        return types.InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    types.InlineKeyboardButton(
                        text="üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å –∫–ª–∏–µ–Ω—Ç—É", url=f"tg://user?id={client_telegram_id}"
                    )
                ],
                [
                    types.InlineKeyboardButton(
                        text="‚úÖ –í–∑—è–ª –≤ —Ä–∞–±–æ—Ç—É", callback_data=f"manager:take:{client_telegram_id}"
                    ),
                    types.InlineKeyboardButton(
                        text="üìä –ò—Å—Ç–æ—Ä–∏—è –∫–ª–∏–µ–Ω—Ç–∞",
                        callback_data=f"manager:history:{client_telegram_id}",
                    ),
                ],
                [
                    types.InlineKeyboardButton(
                        text="üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞",
                        callback_data=f"manager:stats:{client_telegram_id}",
                    ),
                    types.InlineKeyboardButton(text="üîá –ü–∞—É–∑–∞ 1—á", callback_data="manager:mute:60"),
                ],
            ]
        )

    async def handle_manager_callback(self, callback: types.CallbackQuery):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç callback –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤"""

        data_parts = callback.data.split(":")
        action = data_parts[1]

        if action == "take":
            client_id = int(data_parts[2])
            await self._handle_take_client(callback, client_id)

        elif action == "history":
            client_id = int(data_parts[2])
            await self._show_client_history(callback, client_id)

        elif action == "stats":
            client_id = int(data_parts[2])
            await self._show_client_stats(callback, client_id)

        elif action == "mute":
            minutes = int(data_parts[2])
            await self._mute_notifications(callback, minutes)

    async def _handle_take_client(self, callback: types.CallbackQuery, client_id: int):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–∑—è—Ç–∏–µ –∫–ª–∏–µ–Ω—Ç–∞ –≤ —Ä–∞–±–æ—Ç—É"""

        manager_id = callback.from_user.id
        manager_name = callback.from_user.full_name

        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –∞–∫—Ç–∏–≤–Ω—ã–π —á–∞—Ç
            existing_chat = self.db.get_active_chat(client_id)
            if existing_chat and existing_chat.status == "active":
                await callback.answer(
                    f"‚ö†Ô∏è –ö–ª–∏–µ–Ω—Ç —É–∂–µ –æ–±—Å–ª—É–∂–∏–≤–∞–µ—Ç—Å—è –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º ID {existing_chat.manager_telegram_id}",
                    show_alert=True,
                )
                return

            # –ù–∞–∑–Ω–∞—á–∞–µ–º —á–∞—Ç –º–µ–Ω–µ–¥–∂–µ—Ä—É
            chat_id = self.db.assign_chat_to_manager(
                client_id, manager_id, {"name": manager_name, "query": "–í–∑—è—Ç –∏–∑ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"}
            )

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –º–µ–Ω–µ–¥–∂–µ—Ä–∞
            await callback.message.edit_text(
                f"‚úÖ **–ö–ª–∏–µ–Ω—Ç –≤–∑—è—Ç –≤ —Ä–∞–±–æ—Ç—É!**\n\n"
                f"üÜî –ß–∞—Ç ID: {chat_id}\n"
                f"üë®‚Äçüíº –ú–µ–Ω–µ–¥–∂–µ—Ä: {manager_name}\n"
                f"üë§ –ö–ª–∏–µ–Ω—Ç ID: `{client_id}`\n"
                f"üïê –í—Ä–µ–º—è: {datetime.now().strftime('%H:%M')}\n\n"
                f"üí¨ –ü–µ—Ä–µ—Ö–æ–¥–∏—Ç–µ –∫ –¥–∏–∞–ª–æ–≥—É –∏ –æ—Ç–≤–µ—á–∞–π—Ç–µ –∫–ª–∏–µ–Ω—Ç—É.",
                reply_markup=types.InlineKeyboardMarkup(
                    inline_keyboard=[
                        [
                            types.InlineKeyboardButton(
                                text="üí¨ –ü–µ—Ä–µ–π—Ç–∏ –∫ –¥–∏–∞–ª–æ–≥—É", url=f"tg://user?id={client_id}"
                            )
                        ],
                        [
                            types.InlineKeyboardButton(
                                text="‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å —á–∞—Ç",
                                callback_data=f"manager:complete:{client_id}",
                            )
                        ],
                    ]
                ),
                parse_mode="Markdown",
            )

            # –£–≤–µ–¥–æ–º–ª—è–µ–º –¥—Ä—É–≥–∏—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤
            await self.notify_client_taken(client_id, manager_name, manager_id)

            logger.info(
                f"–ö–ª–∏–µ–Ω—Ç {client_id} –≤–∑—è—Ç –≤ —Ä–∞–±–æ—Ç—É –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º {manager_name} ({manager_id})"
            )

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–∑—è—Ç–∏–∏ –∫–ª–∏–µ–Ω—Ç–∞ –≤ —Ä–∞–±–æ—Ç—É: {e}")
            await callback.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.", show_alert=True)

    async def _show_client_history(self, callback: types.CallbackQuery, client_id: int):
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é –∫–ª–∏–µ–Ω—Ç–∞"""

        try:
            # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞
            history = self.db.get_user_history(client_id, limit=10)

            if not history:
                await callback.answer("üì≠ –£ –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π", show_alert=True)
                return

            history_text = f"üìã **–ò—Å—Ç–æ—Ä–∏—è –∫–ª–∏–µ–Ω—Ç–∞ ID: {client_id}**\n\n"

            for i, msg in enumerate(history[:5], 1):
                date_str = msg.timestamp.strftime("%d.%m %H:%M")
                content_preview = msg.content[:50] + "..." if len(msg.content) > 50 else msg.content

                msg_type = "‚ùì" if msg.message_type == MessageType.USER else "‚úÖ"
                history_text += f"{msg_type} **{date_str}**\n_{content_preview}_\n\n"

            if len(history) > 5:
                history_text += f"... –∏ –µ—â–µ {len(history) - 5} —Å–æ–æ–±—â–µ–Ω–∏–π"

            await callback.answer(history_text, show_alert=True)

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ –∫–ª–∏–µ–Ω—Ç–∞ {client_id}: {e}")
            await callback.answer("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏ –∫–ª–∏–µ–Ω—Ç–∞", show_alert=True)

    async def _show_client_stats(self, callback: types.CallbackQuery, client_id: int):
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–ª–∏–µ–Ω—Ç–∞"""

        try:
            stats = self.db.get_user_stats_summary(client_id)

            stats_text = f"üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞ ID: {client_id}**\n\n"
            stats_text += f"üìà –í—Å–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–π: {stats['total_messages']}\n"
            stats_text += f"‚ùì –í–æ–ø—Ä–æ—Å–æ–≤: {stats['user_messages']}\n"
            stats_text += f"‚úÖ –û—Ç–≤–µ—Ç–æ–≤: {stats['assistant_messages']}\n"
            stats_text += f"üí∞ –° upselling: {stats['upselling_messages']}\n"
            stats_text += f"ü§ñ –ê–≤—Ç–æ–æ—Ç–≤–µ—Ç–æ–≤: {stats['auto_responses']}\n"

            if stats["first_message"]:
                first_date = datetime.fromisoformat(stats["first_message"]).strftime("%d.%m.%Y")
                stats_text += f"\nüìÖ –ü–µ—Ä–≤–æ–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ: {first_date}\n"

            stats_text += f"üéØ –ò–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç—Å—è: {stats['top_category']}"

            await callback.answer(stats_text, show_alert=True)

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–ª–∏–µ–Ω—Ç–∞ {client_id}: {e}")
            await callback.answer("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏", show_alert=True)

    async def _mute_notifications(self, callback: types.CallbackQuery, minutes: int):
        """–û—Ç–∫–ª—é—á–∞–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞"""

        manager_id = callback.from_user.id

        try:
            # –í—Ä–µ–º–µ–Ω–Ω–æ –ø–æ–º–µ—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –∫–∞–∫ –∑–∞–Ω—è—Ç–æ–≥–æ
            self.db.update_manager_status(manager_id, ManagerStatus.BUSY)

            # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ —á–µ—Ä–µ–∑ N –º–∏–Ω—É—Ç
            # –ù–∞–ø—Ä–∏–º–µ—Ä, —á–µ—Ä–µ–∑ –∑–∞–¥–∞—á–∏ –≤ —Ñ–æ–Ω–µ –∏–ª–∏ Redis —Å TTL

            await callback.answer(
                f"üîá –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –Ω–∞ {minutes} –º–∏–Ω—É—Ç.\n"
                f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /manager_status –¥–ª—è –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.",
                show_alert=True,
            )

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
            await callback.answer("‚ùå –û—à–∏–±–∫–∞", show_alert=True)

    async def save_assistant_response(
        self, user_id: int, response_text: str, metadata: Optional[Dict] = None
    ) -> int:
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ—Ç–≤–µ—Ç –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é"""
        try:
            if metadata is None:
                metadata = {}

            conv_message = ConversationMessage(
                user_id=user_id,
                message_type=MessageType.ASSISTANT,
                content=response_text,
                category=metadata.get("category"),
                has_upselling=metadata.get("has_upselling", False),
                search_type=metadata.get("search_type"),
                relevance_score=metadata.get("relevance_score"),
                response_time_ms=metadata.get("response_time_ms"),
                manager_id=metadata.get("manager_id"),
                is_auto_response=metadata.get("is_auto_response", False),
            )

            message_id = self.db.save_message(conv_message)
            logger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω –æ—Ç–≤–µ—Ç –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
            return message_id

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞: {e}")
            return 0


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞
def create_notification_system(bot: Bot) -> ManagerNotificationSystem:
    return ManagerNotificationSystem(bot)
